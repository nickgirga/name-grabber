#!/usr/bin/python
# window-name-to-file
# Version 2.0
# Nicholas Girga
# Released under GPL3 with ABSOLUTELY NO WARRANTY

# This script simply creates and/or updates "window-name.txt" in the working
# directory at a set interval of time. This was intended to be used with OBS to
# update labels that show what music is playing in the web browser when all other
# methods fail.

# to-do:
#    - check for runtime deps at start and install if needed
#    - create an elegant quit function that doesn't rely on KB interrupts
#    - create GUI
#    - allow floating point numbers for sleep_time (this requires real GUI first; the current
#      method of displaying "Printed to file" would not function correctly without whole numbers)

### imports
from os.path import expanduser
import subprocess
import time
import sys
import os

### define vars
running = True # determines if the main loop should keep iterating
sleep_time = 1 # the time to sleep inbetween each iteration of the main loop
substring_start = 0 # how much of the start should be cut from window_name
substring_end = 0 # how much of the end should be cut from window_name
desired_window = b'0' # the ID of the window selected by the user
window_name = "" # the full name of the window selected by the user
file_destination = expanduser("~")

### define funcs
# retrieve input (integer only) from the user
def get_input_int(prompt: str) -> int:
    # start a validation loop
    while (True):
        os.system("clear")
        user_input = input(prompt)
        try:
            # try converting to integer
            user_input_int = int(user_input)
            return user_input_int
        except ValueError:
            # report that user_input is not valid and allow loop to continue
            os.system("clear")
            print("\"" + user_input + "\" is not a valid integer. This field only accepts integers.")
            input("Press enter to continue...")
            
# get_input_int but with minimum and maximum limits
def get_input_int_clamped(prompt: str, minimum: int, maximum: int):
    while (True):
        user_input_int = get_input_int(prompt)
        if (minimum <= user_input_int and user_input_int <= maximum):
            # return if user_input is valid
            return user_input_int
        else:
            # report that user_input is out of range and allow loop to continue
            os.system("clear")
            print("\"" + str(user_input_int) + "\" is not within the range of this field. The range is " + str(minimum) + "-" + str(maximum))
            input("Press enter to continue...")

# returns the name of the window that has been passed in
def get_window_name(window: bytes) -> str:
    _window_name = ""

    try:
        # try to call xdotool
        _window_name = subprocess.check_output(["xdotool", "getwindowname", str(int(desired_window))])
    except:
        # exit window-name-to-file if xdotool acts funny
        os.system("clear")
        print("ERR: xdotool could not retrieve the name of the window with the id \"" + str(int(desired_window)) + "\"")
        sys.exit()

    try:
        # clip off the end-line (\n) from _window_name
        _window_name_sub = _window_name[:len(_window_name) - 1]
        # decode _window_name_sub from bytes to string and return it
        return _window_name_sub.decode("utf-8")
    except:
        # report failure of decode
        os.system("clear")
        print("ERR: failed to decode response from xdotool: \"" + str(_window_name) + "\"")
        sys.exit()

# select a window using xdotool
def select_window() -> bytes:
    _desired_window = ""

    os.system("clear")
    print("Please click a window to select it... (waiting - ctrl+c to exit)")

    try:
        # try to call xdotool
        _desired_window = subprocess.check_output(["xdotool", "selectwindow"])
    except:
        # exit window-name-to-file if xdotool acts funny
        os.system("clear")
        print("ERR: xdotool could not retrieve the ID of the selected window!")
        sys.exit()
    # return if _desired_window is of the type 'bytes'
    if (isinstance(_desired_window, bytes)):
        return _desired_window

    # exit if _desired_window is not of the type 'bytes'
    os.system("clear")
    print("ERR: xdotool could not retrieve the ID of the selected window!")
    sys.exit()
    
# prompt user for destination folder using zenity
def ask_for_folder() -> str:
    _file_destination = ""
    try:
        _file_destination = subprocess.check_output(["zenity", "--file-selection", "--directory", "--title", "window-name.txt destination"])
        _file_destination_sub = _file_destination[:len(_file_destination) - 1]
        return _file_destination_sub.decode("utf-8")
    except:
        print("ERR: folder could not be found. Using \"" + str(file_destination) + "\"")
        return file_destination

### start
desired_window = select_window() # ask for desired_window
window_name = get_window_name(desired_window) # fetch the name of desired_window
os.system("clear")
print("The window with the name \"" + window_name + "\" has been selected.")
input("Press enter to continue...")

# settings
sleep_time = get_input_int_clamped("How often should the file update? [seconds]> ", 0, 9999)
substring_start = get_input_int_clamped("Should I cut off any starting characters? > ", 0, len(window_name)) 
substring_end = get_input_int_clamped("Should I cut off any ending characters? > ", 0, len(window_name) - substring_start)
os.system("clear")
print("Please select a folder for window-name.txt to be generated...")
file_destination = ask_for_folder()
os.system("clear")
print("window-name.txt will be generated in \"" + file_destination + "\"")
input("Press enter to start main loop...")

# main loop
while (running):
    os.system("clear")
    # print license info
    print("window-name-to-file is running...")
    print("Version 2.0")
    print("Created by Nicholas Girga")
    print("Released under GPL3 with ABSOLUTELY NO WARRANTY")
    print("To stop window-name-to-file, press ctrl+c")
    print()
    print("Printing to \"" + file_destination + "/window-name.txt\"")
    print()
    # update window_name, pretty_window_name, and inform the user of what it has potentially changed to
    window_name = get_window_name(desired_window)
    pretty_window_name = window_name[substring_start:len(window_name) - substring_end]
    print("The selected window's name is currently \"" + pretty_window_name + "\"")
    time.sleep(sleep_time - 0.3)
    try:
        # print to file
        file = open(file_destination + "/window-name.txt", "w")
        file.write(pretty_window_name)
        file.close()
    except:
        print("ERR: failed to print to file.")
        sys.exit()
    print()
    print("Printed to file.")
    time.sleep(0.3)
